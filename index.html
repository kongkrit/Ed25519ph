<!doctype html>
<head>
  <meta charset="UTF-8"/>
  <title>Ed25519ph Streaming signer</title>
<style>
  :root { color-scheme: dark; }
  body { background:#202020; color:#e0e0e0; }
  * { font-family: monospace, sans-serif; }
</style>
</head>

<h1>Ed25519ph Streaming signer</h1>
<output id="libsodium-status" aria-live="polite">&nbsp;</output>

<section>
  <h2>1) Generate 32-byte random seed</h2>
  <button id="btn-gen" disabled>Generate random seed</button>
  <button id="btn-load" disabled>Load seed from a file</button>
  <button id="btn-save" disabled>Save seed to a file</button>
  <br><br>
  <div>
    <label>Seed Name (load and save affects this)</label><br />
    <textarea id="seed-name" rows="1" cols="80"></textarea>
  </div>
  <div>
    <label>Seed (base64):</label><br />
    <textarea id="seed" rows="3" cols="80" readonly></textarea>
  </div>
  <h3>Seed above is used to derive key pairs:</h3>
  <div>
    <label>Secret key (base64):</label><br />
    <textarea id="sec" rows="3" cols="80" readonly></textarea>
  </div>
  <div>
    <label>Public key (base64):</label><br />
    <textarea id="pub" rows="3" cols="80" readonly></textarea>
  </div>
  <output id="key-status" aria-live="polite">&nbsp;</output>
</section>

<hr />

<section>
  <h2>2) Select file and sign or verify with Ed25519ph (streamed)</h2>
  <input id="file" type="file" />
  <br>
  <div>
    <label for="prog">Progress:</label><br />
    <progress id="prog" value="0" max="100" style="width:500px"></progress>
    <div id="prog-txt" style="font-family:ui-monospace,monospace">&nbsp;</div>
  </div>

  <h3>Sign file with Ed25519ph (streamed)</h3>
  <button id="btn-sign" disabled>Sign file (Ed25519ph)</button>

  <div>
    <label>Ed25519ph Signature (base64):</label><br />
    <textarea id="sig" rows="3" cols="80" readonly></textarea>
  </div>
  <br>
  
  <h3>Verify file signature with Ed25519ph (streamed)</h3>
  <button id="btn-verify" disabled>Verify file (Ed25519ph)</button>
  
  <div>
    <label>Verification result:</label><br />
    <textarea id="ver" rows="3" cols="80" readonly></textarea>
  </div>
  <br>
</section>

<!-- Local UMD bundle -->
<script src="sodium-sumo.js"></script>

<script>
/* ---------- Internal logic (no DOM) ---------- */

// Base64 helpers
const b64 = {
  fromU8(u8) {
    let bin = "";
    for (let i = 0; i < u8.length; i++) bin += String.fromCharCode(u8[i]);
    return btoa(bin);
  },
  toU8(s) {
    const bin = atob(s);
    const out = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) out[i] = bin.charCodeAt(i);
    return out;
  }
};

// Chunked reader using File.slice + FileReader (Safari/iPad safe)
async function* readFileChunks(file, chunkSize = 2 ** 20) {
  let offset = 0;
  while (offset < file.size) {
    const slice = file.slice(offset, offset + chunkSize);
    const buf = await new Promise((res, rej) => {
      const fr = new FileReader();
      fr.onerror = () => rej(fr.error);
      fr.onload = () => res(fr.result);
      fr.readAsArrayBuffer(slice);
    });
    yield new Uint8Array(buf);
    offset += chunkSize;
  }
}

// Multipart signing API (UMD exposes crypto_sign_* streaming).
// Note: This signs with Ed25519 streaming. Your uploaded UMD build does not
// expose the ed25519ph-specific functions.
const Ed25519ph = (() => {
  async function ready() { await sodium.ready; }

  // 1) Generate a random 32-byte seed
  async function genSeed() {
    await ready();
    const seed = new Uint8Array(sodium.crypto_sign_SEEDBYTES);
    crypto.getRandomValues(seed);
    return seed; // 32 bytes
  }

  // 2) Derive keypair from provided 32-byte seed
  async function genKeyPair(seed) {
    await ready();
    if (!(seed instanceof Uint8Array) || seed.length !== sodium.crypto_sign_SEEDBYTES) {
      throw new Error("seed must be Uint8Array(32)");
    }
    const { publicKey, privateKey } = sodium.crypto_sign_seed_keypair(seed);
    return { publicKey, privateKey };
  }

  async function signOrVerifyStream(mode, file, privateKey, publicKey, signatureToValidate, { chunkSize = 2 ** 20, onProgress } = {}) {
  await ready();
  const state = sodium.crypto_sign_init(); // streaming state
  let processed = 0;
  for await (const chunk of readFileChunks(file, chunkSize)) {
    sodium.crypto_sign_update(state, chunk);
    processed += chunk.length;
    if (onProgress) onProgress({ processed, total: file.size });
  }
  if (mode === "sign") {
    if (!privateKey) throw new Error("privateKey required for sign");
    return sodium.crypto_sign_final_create(state, privateKey); // Uint8Array(64)
  } else if (mode === "verify") {
    if (!publicKey) throw new Error("publicKey required for verify");
    if (!(signatureToValidate instanceof Uint8Array)) throw new Error("signatureToValidate must be Uint8Array");
    const ok = sodium.crypto_sign_final_verify(state, signatureToValidate, publicKey);
    return ok === true; // boolean
  }
  throw new Error("Unknown mode: " + mode);
}

return { ready, genSeed, genKeyPair, signOrVerifyStream };
})();
</script>

<script>
/* ---------- Minimal DOM wiring ---------- */
(async () => {
  const $ = (id) => document.getElementById(id);


let libsodiumReady = false; // set true after first successful Ed25519ph.ready()

function updateControls() {
  // Do nothing until libsodium is ready
  if (!libsodiumReady) return;
  const hasFile = !!($("file") && $("file").files && $("file").files.length > 0);
  const secVal = ($("sec")?.value || "").trim();
  const pubVal = ($("pub")?.value || "").trim();
  const sigVal = ($("sig")?.value || "").trim();

  // Base enables after libsodium becomes ready
  $("btn-gen").disabled = false;
  $("btn-load").disabled = false;
  $("btn-save").disabled = false;
  $("file").disabled = false;

  // Conditional enables
  $("btn-sign").disabled = !(hasFile && secVal !== "");
  $("btn-verify").disabled = !(hasFile && pubVal !== "" && sigVal !== "");
}


async function withProgress(statusLabel, run) {
  $("btn-gen").disabled = true;
  $("btn-load").disabled = true;
  $("btn-save").disabled = true;
  $("btn-sign").disabled = true;
  $("btn-verify").disabled = true;
  $("file").disabled = true;
  $("key-status").value = statusLabel;
  const prog = $("prog");
  const progTxt = $("prog-txt");
  const fmt = (n) => (n / (1024 * 1024)).toFixed(2) + " MiB";
  const onProgress = ({ processed, total }) => {
    const pct = total ? Math.floor((processed / total) * 100) : 0;
    prog.max = 100;
    prog.value = pct;
    progTxt.textContent = `${pct}%  ${fmt(processed)} / ${fmt(total)}`;
  };
  try {
    const result = await run(onProgress);
    $("key-status").value = "Done.";
    return result;
  }
  finally {
    updateControls();
  }
}

  // Buttons are disabled in HTML at startup. Enable after libsodium is ready.
  try {
    await Ed25519ph.ready();
    libsodiumReady = true;
    const ls = document.getElementById("libsodium-status");
    if (ls) ls.value = "libsodium ready";
    updateControls();
    } catch (e) {
    const ls = document.getElementById("libsodium-status");
    if (ls) ls.value = "libsodium failed to initialize: " + (e && e.message ? e.message : e);
    // keep buttons disabled
  }

  let keys = { publicKey: null, privateKey: null };

  function isoLocal() {
    const d = new Date();
    const tz = -d.getTimezoneOffset();
    const sign = tz >= 0 ? '+' : '-';
    const pad = n => String(Math.floor(Math.abs(n))).padStart(2, '0');
    const h = pad(tz / 60);
    const m = pad(tz % 60);
    return d.getFullYear() + '-' +
           pad(d.getMonth() + 1) + '-' +
           pad(d.getDate()) + 'T' +
           pad(d.getHours()) + ':' +
           pad(d.getMinutes()) + ':' +
           pad(d.getSeconds()) + sign + h + ':' + m;
  }

  $("btn-gen").addEventListener("click", async () => {
    try {
      const seed = await Ed25519ph.genSeed();
      $("seed").value = b64.fromU8(seed);
      // Add ISO timestamp to seed-name
      const nm = document.getElementById("seed-name");
      if (nm) nm.value = isoLocal();
      $("key-status").value = "Seed generated.";
      $("seed").dispatchEvent(new Event("input"));
    } catch (e) {
      $("key-status").value = "Seed generation failed: " + e.message;
    }
  });

  // Treat #seed as source of truth. Any change derives keys.
  $("seed").addEventListener("input", async () => {
    try {
      const seedB64 = document.getElementById('seed').value.trim();
      if (!seedB64) {
        keys = { publicKey: null, privateKey: null };
        $("pub").value = "";
        $("sec").value = "";
        $("key-status").value = "Seed empty.";
        updateControls();
        return;
      }
      let seedU8;
      try {
        seedU8 = b64.toU8(seedB64);
      } catch (e) {
        $("key-status").value = "Invalid base64 seed.";
        updateControls();
        return;
      }
      if (seedU8.length !== 32) {
        $("key-status").value = "Seed must be 32 bytes (base64-encoded).";
        updateControls();
        return;
      }
      const { publicKey, privateKey } = await Ed25519ph.genKeyPair(seedU8);
      keys = { publicKey, privateKey };
      $("pub").value = b64.fromU8(publicKey);
      $("sec").value = b64.fromU8(privateKey);
      $("key-status").value = "Key pair ready.";
      updateControls();
    } catch (e) {
      keys = { publicKey: null, privateKey: null };
      $("pub").value = "";
      $("sec").value = "";
      $("key-status").value = "Key derivation failed: " + e.message;
      updateControls();
    }
  });

  // Save seed as JSON { "name": "<seed-name>", "seedB64": "<value>" }
  $("btn-save").addEventListener("click", () => {
    try {
      const seedB64 = document.getElementById('seed').value.trim();
      const name = (document.getElementById('seed-name')?.value || "").trim();
      const obj = { name, seedB64 };
      const blob = new Blob([JSON.stringify(obj, null, 2)], { type: "application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "seed.json";
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(a.href);
      a.remove();
      const ks = document.getElementById("key-status");
      if (ks) ks.value = "Seed JSON ready for download.";
    } catch (e) {
      const ks = document.getElementById("key-status");
      if (ks) ks.value = "Save failed: " + e.message;
    }
  });

  // Load seed from JSON { "name": "<seed-name>", "seedB64": "<value>" }
  $("btn-load").addEventListener("click", async () => {
    try {
      const inp = document.createElement("input");
      inp.type = "file";
      inp.accept = "application/json,.json";
      const file = await new Promise((res) => {
        inp.onchange = () => res(inp.files && inp.files[0]);
        inp.click();
      });
      if (!file) return;
      const text = await file.text();
      let obj;
      try { obj = JSON.parse(text); }
      catch (e) { $("key-status").value = "Invalid JSON."; return; }
      const name = typeof obj.name === "string" ? obj.name : "";
      const seedB64 = typeof obj.seedB64 === "string" ? obj.seedB64 : "";
      if (!seedB64) { $("key-status").value = "Missing seedB64."; return; }
      const nmEl = document.getElementById("seed-name");
      if (nmEl) nmEl.value = name;
      $("seed").value = seedB64.trim();
      $("key-status").value = "Seed loaded.";
      // Trigger derivation
      $("seed").dispatchEvent(new Event("input"));
    } catch (e) {
      $("key-status").value = "Load failed: " + e.message;
    }});

  

// Keep buttons in sync with inputs
$("file").addEventListener("change", () => {
  $("sig").value = "";
  $("ver").value = "";
  updateControls();
});
$("sig").addEventListener("input", () => updateControls());

  $("btn-sign").addEventListener("click", async () => {
  const f = $("file").files && $("file").files[0];
  if (!f) { alert("Select a file first"); return; }
  if (!keys.privateKey) { alert("Generate a key pair first"); return; }
  try {
    $("sig").value = "";
    const sig = await withProgress("Signing…", (onProgress) =>
      Ed25519ph.signOrVerifyStream("sign", f, keys.privateKey, null, null, { onProgress })
    );
    $("sig").value = b64.fromU8(sig);
    updateControls();
  } catch (e) {
    alert("Signing failed: " + e.message);
  }
});
$("btn-verify").addEventListener("click", async () => {
  const f = $("file").files && $("file").files[0];
  if (!f) { alert("Select a file first"); return; }
  if (!keys.publicKey) { alert("Generate or load a public key first"); return; }
  const sigB64 = $("sig").value.trim();
  if (!sigB64) { alert("Provide a base64 signature in the Signature field"); return; }
  let sigU8;
  try { sigU8 = b64.toU8(sigB64); } catch (e) { alert("Invalid base64 signature"); return; }
  try {
    $("ver").value = "";
    const ok = await withProgress("Verifying…", (onProgress) =>
      Ed25519ph.signOrVerifyStream("verify", f, null, keys.publicKey, sigU8, { onProgress })
    );
    $("ver").value = ok ? "OK" : "BAD";
  } catch (e) {
    alert("Verify failed: " + e.message);
  }
});
})();

</script>
</html>
