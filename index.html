<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<title>Ed25519ph Stream Sign (libsodium + Web Crypto)</title>

<h1>Ed25519ph streaming sign demo</h1>

<section>
  <h2>1) Generate Ed25519 key pair (seeded by Web Crypto)</h2>
  <button id="btn-gen">Generate key pair</button>
  <div>
    <label>Public key (base64):</label><br />
    <textarea id="pub" rows="3" cols="80" readonly></textarea>
  </div>
  <div>
    <label>Secret key (base64):</label><br />
    <textarea id="sec" rows="3" cols="80" readonly></textarea>
  </div>
</section>

<hr />

<section>
  <h2>2) Select file and sign with Ed25519ph (streamed)</h2>
  <input id="file" type="file" />
  <button id="btn-sign">Sign file (Ed25519ph)</button>
  <div>
    <label>Signature (base64):</label><br />
    <textarea id="sig" rows="3" cols="80" readonly></textarea>
  </div>
</section>

<!-- Local UMD bundle (you uploaded this). Avoids CORS. -->
<script src="sodium-sumo.js"></script>

<script>
/* ---------- Internal logic (no DOM here) ---------- */

// Base64 helpers
const b64 = {
  fromU8(u8) {
    let bin = "";
    for (let i = 0; i < u8.length; i++) bin += String.fromCharCode(u8[i]);
    return btoa(bin);
  },
  toU8(s) {
    const bin = atob(s);
    const out = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) out[i] = bin.charCodeAt(i);
    return out;
  }
};

// Chunked reader using File.slice + FileReader (works on Safari/iPad)
async function* readFileChunks(file, chunkSize = 2 ** 20) {
  let offset = 0;
  while (offset < file.size) {
    const slice = file.slice(offset, offset + chunkSize);
    const buf = await new Promise((res, rej) => {
      const fr = new FileReader();
      fr.onerror = () => rej(fr.error);
      fr.onload = () => res(fr.result);
      fr.readAsArrayBuffer(slice);
    });
    yield new Uint8Array(buf);
    offset += chunkSize;
  }
}

// Ed25519ph via libsodium multi-part API: crypto_sign_init/update/final_create
const Ed25519ph = (() => {
  async function ready() { await sodium.ready; }

  async function genKeyPair() {
    await ready();
    const seed = new Uint8Array(sodium.crypto_sign_SEEDBYTES);
    crypto.getRandomValues(seed);
    const { publicKey, privateKey } = sodium.crypto_sign_seed_keypair(seed);
    return { publicKey, privateKey }; // pk:32, sk:64
  }

  async function signFileStream(file, privateKey, chunkSize = 2 ** 20) {
    await ready();
    const state = sodium.crypto_sign_init(); // returns state object
    for await (const chunk of readFileChunks(file, chunkSize)) {
      sodium.crypto_sign_update(state, chunk);
    }
    return sodium.crypto_sign_final_create(state, privateKey); // Uint8Array(64)
  }

  return { ready, genKeyPair, signFileStream };
})();
</script>

<script>
/* ---------- Minimal DOM wiring ---------- */
(async () => {
  try {
    await Ed25519ph.ready();
    alert("libsodium is ready"); // explicit requirement
  } catch (e) {
    alert("libsodium failed to initialize: " + (e && e.message ? e.message : e));
  }

  const $ = (id) => document.getElementById(id);
  let keys = { publicKey: null, privateKey: null };

  $("btn-gen").addEventListener("click", async () => {
    try {
      keys = await Ed25519ph.genKeyPair();
      $("pub").value = b64.fromU8(keys.publicKey);
      $("sec").value = b64.fromU8(keys.privateKey);
    } catch (e) {
      alert("Key generation failed: " + e.message);
    }
  });

  $("btn-sign").addEventListener("click", async () => {
    const f = $("file").files && $("file").files[0];
    if (!f) { alert("Select a file first"); return; }
    if (!keys.privateKey) { alert("Generate a key pair first"); return; }

    try {
      const sig = await Ed25519ph.signFileStream(f, keys.privateKey);
      $("sig").value = b64.fromU8(sig);
    } catch (e) {
      alert("Signing failed: " + e.message);
    }
  });
})();
</script>
</html>
